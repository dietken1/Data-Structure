# 자료구조 4차 과제 보고서
### 그래프를 생성하고, 이 그래프의 최단경로를 구하는 알고리즘을 구현
Dijkstra 알고리즘과 Bellman-Ford 알고리즘을 이용해서 그래프 생성 및 경로를 구하는 프로그램을 작성.


## 전체 구조
먼저, 양의 가중치만 존재하는 그래프를 다루는 데 사용되는 Dijkstra 알고리즘과 음
의 가중치가 존재하는 그래프를 다루는 데 사용되는 Bellman-Ford 알고리즘을 모두 
사용하도록 설계하였습니다. 또한, 각각의 알고리즘 내에서도 그래프를 어떤 자료구조
로 표현하였느냐에 따라서 최단 경로를 계산하는 방식을 두 가지로 구분하였습니다.
기본적으로 0번 정점에서 시작하여 각 정점까지의 최단 경로를 구하도록 설계하였습
니다.
프로그램을 실행시키면 우선 사용자에게 정점의 개수, 간선의 개수, 음의 가중치 허
용 여부를 입력받습니다. 그 후, 사용자에게 각 간선에 대한 정보를 입력받습니다. 출
발 정점, 도착 정점, 간선의 가중치를 공백으로 구분하여 한 줄에 입력받습니다.
모든 간선에 대한 정보를 입력받으면, generate_graph 함수를 통해서 그래프를 생
성합니다.
그 후, show_graph 함수를 통해서 생성된 그래프를 인접 행렬 형태로 출력해줍니
다. 
그러고 나서 음의 가중치 허용 여부에 따라서 shortest_path_from_matrix_graph 
함수와 shortest_path_from_list_graph 함수를 이용하여 알맞은 알고리즘 함수를 
호출하고, 인접 행렬 형식과 인접 리스트 형식의 그래프의 최단 경로를 각각 출력합
니다.


## main 함수
main 함수에서는 정점의 개수, 간선의 개수, 음의 가중치 허용 여부를 사용자에게 입
력받습니다. 그 후, 그래프 생성을 수행하도록 generate_graph 함수를 호출하는 역
할을 수행합니다. 음의 가중치를 나타내는 변수는 flag로, flag==1이면 음의 가중치가 
허용됨을 의미합니다.


## generate_graph 함수
generate_graph 함수는 main 함수로부터 정점의 개수 n, 간선의 개수 e, 음의 가중
치 허용 여부를 나타내는 변수 flag를 매개변수로 전달받습니다. 이를 바탕으로 n*n 
크기의 인접 행렬과 인접 리스트를 동적으로 할당하고 초기화해줍니다.
이후, 사용자에게 간선에 대한 정보를 입력받습니다. 간선 하나를 입력받을 때마다 
해당 간선을 두 형식의 그래프에 추가해줍니다. 이 과정에서, 저는 정점의 번호가 사
용자가 지정한 정점 개수의 범위에서 초과했는지, 해당 간선이 self edge인지, 해당 
간선이 그래프에 추가되면 Multi-graph가 형성되는지, 음의 가중치가 허용되지 않았
는데도 음의 가중치를 입력했는지, 이렇게 총 4단계에 걸쳐서 사용자의 입력이 적절
한지를 확인합니다. 만약 이 중 하나의 검사에서라도 걸리면 다시 간선에 대한 정보
를 입력하도록 합니다.
 matrix[u][v]는 정점 u에서 정점 v로 가는 간선의 가중치를 나타내고, 간선이 존재
하지 않으면 매우 큰 숫자인 INF로, 자기 자신에 대해서는 0으로 나타냈습니다.
 adjList[u]는 정점 u에서 출발하는 간선의 정보들이 link로 연결되어 표현되도록 나
타냈습니다.


## show_graph 함수
 show_graph 함수는 정점의 개수 n과 인접 행렬을 매개변수로 받습니다. 인접 행렬
로 표현된 그래프를 이중 for문을 이용해서 정렬된 인접 행렬 형태로 출력하는 동작
을 수행합니다. 두 정점 사이에 경로가 존재하지 않는 부분은 INF를 출력합니다. 


## shortest_path_from_matrix_graph 함수
shortest_path_from_matrix_graph 함수에서는 인접 행렬로 표현된 그래프의 최단 
경로를 구하는 동작을 수행합니다. 이 함수는 매개변수로 앞서 말한 flag, n, 그리고 
인접 행렬 matrix를 받습니다.
함수의 매개변수를 과제 안내문에 제시된 것과 다르게 구성한 이유는 사용자의 입력
에 의해서 그래프가 동적으로 할당되다 보니 그래프를 generate_graph 함수에서 지
역변수로 선언하게 되었고, 이를 사용하기 위해선 매개변수로 전달하여 사용하는 것
이 방법이라고 생각했기 때문입니다.
전달받은 flag가 0이면 dijkstra_matrix 함수를, 1이면 bellman_ford_matrix 함수
를 호출하여 최단 경로를 구하도록 동작합니다.


## shortest_path_from_list_graph 함수
shortest_path_from_list_graph 함수에서는 인접 리스트로 표현된 그래프의 최단 
경로를 구하는 동작을 수행합니다.
이 함수도 앞선 shortest_path_from_matrix_graph 함수와 마찬가지로 flag와 n을 
매개변수로 받지만, 인접 행렬이 아닌 인접 리스트를 매개변수로 받습니다. 
전달받은 flag가 0이면 dijkstra_list 함수를, 1이면 bellman_ford_list 함수를 호출
하여 최단 경로를 구하도록 동작합니다.


## dijkstra_matrix 함수
dijkstra_matrix 함수에서는 Dijkstra 알고리즘을 사용하여 인접 행렬로 표현된 그래
프의 최단 경로를 구합니다. 이 알고리즘은 양의 가중치만을 가지는 경우에만 작동하
기에, flag가 0일 때만 사용됩니다.
이 함수에서는 3개의 배열이 사용되는데, 0번 정점에서부터 각 정점까지의 최단 거
리를 나타내는 distance, 정점이 path에 포함되었는지 알려주는 found, 최단 경로의 
실제 정점을 거치는 순서를 파악하기 위한 pi가 사용됩니다.
 Dijkstra 알고리즘은 매 단계 현재까지 구한 최단 경로 중에서 가장 짧은 경로를 선
택하고, 이를 기반으로 다른 노드들의 최단 경로를 업데이트하는 과정을 반복하는 방
식으로 최단 경로를 획득합니다.
또한, 편의를 위해서 시작 정점은 0번으로 고정하였고, 함수의 마지막엔 3개 배열의 
할당을 해제해줌으로써 자원관리 부분도 신경을 썼습니다.


## dijkstra_list 함수
dijkstra_list 함수는 dijkstra_matrix 함수와 마찬가지로, Dijkstra 알고리즘을 이용
하여 인접 리스트로 표현된 그래프의 최단 경로를 구합니다. 전반적인 내용은 앞서 
설명한 dijkstra_matrix 함수와 동일합니다.


## bellman_ford_matrix 함수
bellman_ford_matrix 함수에서는 Bellman-Ford 알고리즘을 사용하여 인접 행렬로 
표현된 그래프의 최단 경로를 구합니다. 이 알고리즘은 Dijkstra 알고리즘과는 다르
게 음의 사이클만 없다면, 음의 가중치를 가진 간선도 처리할 수 있기 때문에 flag가 
1인 경우에 사용됩니다.
이 함수에서는 2개의 배열만 사용되는데, 0번 정점에서부터 각 정점까지의 최단 거
리를 나타내는 dist와 최단 경로의 실제 정점을 거치는 순서를 파악하기 위한 pi가 
사용됩니다.
 Bellman-Ford 알고리즘은 모든 간선에 대해 반복적으로 최단 경로를 업데이트하는 
과정을 반복하는 방식으로 최단 경로를 획득합니다. 또한, Bellman-Ford 알고리즘은 
앞서 말했듯이 음의 사이클이 있는 경우엔 최단 경로를 구할 수 없기 때문에, 음의 
사이클이 존재하는지 확인하는 부분을 추가하였습니다.


## bellman_ford_list 함수
bellman_ford_list 함수는 bellman_ford_matrix 함수와 마찬가지로, Bellman-Ford 
알고리즘을 이용하여 인접 리스트로 표현된 그래프의 최단 경로를 구합니다. 전반적
인 내용은 앞서 설명한 bellman_ford_matrix 함수와 동일합니다.


## 사용 방법
1. 프로그램을 실행하면 정점의 개수, 간선의 개수, 음의 가중치 허용 여부를 입력하라는 메시지가 순서대로 출력됩니다. 해당하는 각 값을 차례대로 입력하면 됩니다.
2. 위의 입력을 마치면 간선의 정보를 입력하라는 메시지가 출력됩니다. 출발 정점, 도착 정점, 가중치를 한 줄에 공백으로 구분해서 입력하면 됩니다.
3. 만약 사용자가 입력한 간선이 앞서 generate_graph 함수 부분에서 언급한 조건에 걸린다면, 에러 메시지가 출력되고, 사용자는 다시 입력해야 합니다.
4. 모든 간선이 정상적으로 입력되면, 그래프가 인접 행렬의 형태로 출력됩니다.
5. 이후, 인접 행렬로 표현된 그래프와 인접 리스트로 표현된 그래프의 최단 경로의 길이와 해당 경로의 순서를 각각 구분해서 출력하고 프로그램이 종료됩니다.

   
## 시간복잡도 비교분석 결과
저는 최단 경로를 구하는 코드를 dijkstra_matrix, dijkstra_list, bellman_ford_matrix, bellman_ford_list, 4개의 함수에 각각 나누어서 구현하였기에,
이 함수들을 바탕으로 제가 작성한 shortest_path_from_matrix_graph 함수와 shortest_path_from_list_graph 함수의 시간복잡도를 비교하겠습니다. (Multi graph를 허용하지 않는 기준입니다.)

**Dijkstra 알고리즘**의 경우, 최단 거리의 정점을 찾는데 O(n), 거리 갱신을 하는데 O(n)으로, 이것이 이중 for문을 통해 진행되므로 인접 행렬과 인접 리스트 두 경우 모두 시간복잡도가 O(n^2)으로 거의 동일합니다.
물론 인접 리스트의 경우, 간선의 개수가 적다면 미세하게 시간복잡도가 더 낮을 수도 있습니다. 또한, 우선순위 큐를 사용한다면 인접 리스트의 경우, 시간복잡도를 O(nlog(n))까지 줄일 수도 있음을 확인하였습니다.
 
**Bellman-Ford 알고리즘**의 경우, 인접 행렬은 거리 갱신을 위해 각 정점을 도는데, 정점별로 간선을 파악하는데 O(n)의 시간복잡도가
필요하고, 그리고 이 전체 과정을 n-1번 반복합니다. 즉, 3중 for문을 통해 진행되므로, 약 O(n^3)의 시간 복잡
도를 보여줍니다.
반면 인접 리스트의 경우, 마찬가지로 거리 갱신을 위해서 각 정점을 도는데는 O(n)이 필요하지만,
각 정점별로 간선을 파악하는 데는 정점으로 들어오는 간선의 개수 E에 따른 O(E)만큼만 필요하므로,
총 시간복잡도는 으로, 최선의 경우엔 , 최악의 경우엔 의 시간복잡도를 보여줍니다.
즉, 간선의 개수에 따라서 시간복잡도가 달라질 수 있습니다.


## 실행 결과
1. **음의 가중치를 허용하지 않는 그래프**

![image](https://github.com/user-attachments/assets/835d3e04-1c57-4787-8360-46e8e53cbc42)

위 사진은 강의 노트에 있는 그래프입니다. 이 그래프를 바탕으로 동작 실험을 진행
하였고, 조건 체크, 입출력 모두 정상적으로 진행됨을 확인할 수 있었습니다.
아래 사진은 그 결과입니다.

![image](https://github.com/user-attachments/assets/679160d0-2dc1-4cda-bad7-86f6092e94cc)

2. **음의 가중치를 허용하는 그래프**
   
![image](https://github.com/user-attachments/assets/592de119-8ee0-492b-8bd4-619694525d11)

위 사진은 강의 노트에 있는 그래프입니다. 이 그래프를 바탕으로 동작 실험을 진행
하였고, 조건 체크, 입출력 모두 정상적으로 진행됨을 확인할 수 있었습니다.
아래 사진은 그 결과입니다

![image](https://github.com/user-attachments/assets/03c7bcd5-54bc-4146-bbe6-229a5bc216ab)
